<?xml version="1.0" encoding="us-ascii"?>
<test-set xmlns="http://www.w3.org/2010/09/qt-fots-catalog" name="app-UseCaseJSONiq">
   <description>Tests from the JSONiq use cases, coded using XQuery 4.0 syntax</description>
            

   <test-case name="JSONiq-1.1.1-a">
      <description>Joins</description>
      <created by="Michael Kay" on="2025-08-13"/>
      <dependency type="spec" value="XQ40+"/>      
      <test>let $input := (
         {
           "name" : "Sarah",
           "age" : 13,
           "gender" : "female",
           "friends" : [ "Jim", "Mary", "Jennifer"]
         },
        
         {
           "name" : "Jim",
           "age" : 13,
           "gender" : "male",
           "friends" : [ "Sarah" ]
         } )
         return
(:
      JSONiq:
      The following query performs a join on Sarah's friend list to return the Object representing each of her friends:
      Example 1.1. A join query.
      for $sarah in collection("users"),
          $friend in collection("users")
      where $sarah.name eq "Sarah"
            and
            (some $name in $sarah.friends[]
             satisfies $friend.name eq $name)
      return $friend
:)

      for $sarah in $input,
          $friend in $input
      where $sarah?name eq "Sarah"
            and
            (some $name in $sarah?friends?*
             satisfies $friend?name eq $name)
      return $friend       
      </test>
      <result>
         <assert-deep-eq>{ "name" : "Jim", "age" : 13, "gender" : "male", "friends" : [ "Sarah" ] }</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="JSONiq-1.1.1-b">
      <description>Joins</description>
      <created by="Michael Kay" on="2025-08-13"/>
      <dependency type="spec" value="XQ40+ XP40+"/>      
      <test>let $input := (
         {
           "name" : "Sarah",
           "age" : 13,
           "gender" : "female",
           "friends" : [ "Jim", "Mary", "Jennifer"]
         },
        
         {
           "name" : "Jim",
           "age" : 13,
           "gender" : "male",
           "friends" : [ "Sarah" ]
         }
       ) return
(:
      JSONiq:
      let $sarah := collection("users")[$$.name eq "Sarah"]
      for $friend in $sarah.friends[]
      return collection("users")[$$.name eq $friend]
:)

      let $sarah := $input[?name eq "Sarah"]
      for $friend in $sarah?friends?*
      return $input[?name eq $friend]
      
      </test>
      <result>
         <assert-deep-eq>{ "name" : "Jim", "age" : 13, "gender" : "male", "friends" : [ "Sarah" ] }</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="JSONiq-1.1.2-a">
      <description>Grouping</description>
      <created by="Michael Kay" on="2025-08-13"/>
      <dependency type="spec" value="XQ40+ XP40+"/>      
      <test>
         let $sales := (
            { "product" : "broiler", "store number" : 1, "quantity" : 20  },
            { "product" : "toaster", "store number" : 2, "quantity" : 100 },
            { "product" : "toaster", "store number" : 2, "quantity" : 50 },
            { "product" : "toaster", "store number" : 3, "quantity" : 50 },
            { "product" : "blender", "store number" : 3, "quantity" : 100 },
            { "product" : "blender", "store number" : 3, "quantity" : 150 },
            { "product" : "socks", "store number" : 1, "quantity" : 500 },
            { "product" : "socks", "store number" : 2, "quantity" : 10 },
            { "product" : "shirt", "store number" : 3, "quantity" : 10 }
         ) return
(:
      JSONiq:
      {|
         for $sales in collection("sales")
         let $pname := $sales.product
         group by $pname
         return { $pname : sum($sales.quantity) }
      |}
:)

      {
         for $sale in $sales
         let $pname := $sale?product
         group by $pname
         return { $pname : sum($sale?quantity) }
      }
      
      </test>
      <result>
         <assert-deep-eq>{ "toaster" : 200, "blender" : 250, "shirt" : 10, "socks" : 510, "broiler" : 20 }</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="JSONiq-1.1.2-b">
      <description>Grouping</description>
      <created by="Michael Kay" on="2025-08-13"/>
      <dependency type="spec" value="XQ40+ XP40+"/>      
      <test>
         let $sales := (
            { "product" : "broiler", "store number" : 1, "quantity" : 20  },
            { "product" : "toaster", "store number" : 2, "quantity" : 100 },
            { "product" : "toaster", "store number" : 2, "quantity" : 50 },
            { "product" : "toaster", "store number" : 3, "quantity" : 50 },
            { "product" : "blender", "store number" : 3, "quantity" : 100 },
            { "product" : "blender", "store number" : 3, "quantity" : 150 },
            { "product" : "socks", "store number" : 1, "quantity" : 500 },
            { "product" : "socks", "store number" : 2, "quantity" : 10 },
            { "product" : "shirt", "store number" : 3, "quantity" : 10 }
         )
         let $products := (
            { "name" : "broiler", "category" : "kitchen", "price" : 100, "cost" : 70 },
            { "name" : "toaster", "category" : "kitchen", "price" : 30, "cost" : 10 },
            { "name" : "blender", "category" : "kitchen", "price" : 50, "cost" : 25 },
            { "name" : "socks", "category" : "clothes", "price" : 5, "cost" : 2 },
            { "name" : "shirt", "category" : "clothes", "price" : 10, "cost" : 3 }
         )
         let $stores := (
            { "store number" : 1, "state" : "CA" },
            { "store number" : 2, "state" : "CA" },
            { "store number" : 3, "state" : "MA" },
            { "store number" : 4, "state" : "MA" }
         )   
         return
(:
      JSONiq:
      {|
         for $store in collection("stores")
         let $state := $store.state
         group by $state
         return {
           $state : {|
             for $product in collection("products")
             let $category := $product.category
             group by $category
             return {
               $category : {|
                 for $sales in collection("sales")
                 where (some $s in $store
                       satisfies $sales."store number" eq $s."store number")
                   and (some $p in $product
                       satisfies $sales.product eq $p.name)
                 let $pname := $sales.product
                 group by $pname
                 return { $pname : sum( $sales.quantity ) }
               |}
             }
           |}
         }
       |}
:)

      {
         for $store in $stores
         let $state := $store?state
         group by $state
         return {
           $state : {
             for $product in $products
             let $category := $product?category
             group by $category
             return {
               $category : {
                 for $sale in $sales
                 where (some $s in $store
                       satisfies $sale?"store number" eq $s?"store number")
                   and (some $p in $product
                       satisfies $sale?product eq $p?name)
                 let $pname := $sale?product
                 group by $pname
                 return { $pname : sum( $sale?quantity ) }
               }
             }
           }
         }
       }
      
      </test>
      <result>
         <assert-deep-eq>{ "MA" : { "clothes" : { "shirt" : 10 }, 
                                    "kitchen" : { "toaster" : 50, "blender" : 250 } 
                                  }, 
                           "CA" : { "clothes" : { "socks" : 510 }, 
                                    "kitchen" : { "toaster" : 150, "broiler" : 20 } 
                                   } 
                          }</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="JSONiq-1.1.3">
      <description>Transformation</description>
      <created by="Michael Kay" on="2025-08-13"/>
      <dependency type="spec" value="XQ40+ XP40+"/>      
      <test>
         let $satellites :=
         {
            "creator" : "Satellites plugin version 0.6.4",
            "satellites" : {
              "AAU CUBESAT" : {
                "tle1" : "1 27846U 03031G 10322.04074654  .00000056  00000-0  45693-4 0  8768",
                "visible" : false()
              },
              "AJISAI (EGS)" : {
                "tle1" : "1 16908U 86061A 10321.84797408 -.00000083  00000-0  10000-3 0  3696",
                "visible" : true()
              },
              "AKARI (ASTRO-F)" : {
                "tle1" : "1 28939U 06005A 10321.96319841  .00000176  00000-0  48808-4 0  4294",
                "visible" : true()
              }
            }
          } return
(:
      JSONiq:
      let $sats := collection("satellites").satellites
         return {
           "visible" : [
              for $sat in keys($sats)
              where $sats.$sat.visible
              return $sat
           ],
           "invisible" : [
              for $sat in keys($sats)
              where not $sats.$sat.visible
              return $sat
           ]
         }
:)

      let $sats := $satellites ? satellites
      return {
        "visible" : array {
           map:keys($sats?[?value?visible])
        },
        "invisible" : array {
           map:keys($sats?[not(?value?visible)])
        }
      }
      
      </test>
      <result>
         <assert-deep-eq>{ "visible" : [ "AJISAI (EGS)", "AKARI (ASTRO-F)" ], "invisible" : [ "AAU CUBESAT" ] }</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="JSONiq-1.1.4">
      <description>Updates</description>
      <created by="Michael Kay" on="2025-08-13"/>
      <dependency type="spec" value="XQ40+ XP40+"/>      
      <test>
         let $orders := 
         {
           "user" : "Deadbeat Jim",
           "credit card" : "VISA 4111 1111 1111 1111",
           "product" : "lottery tickets",
           "quantity" : 243
         }
         let $users := 
         {
           "name" : "Deadbeat Jim",
           "address" : "1 E 161st St, Bronx, NY 10451",
           "risk tolerance" : "high"
         }
      (:
         JSONiq:
         let $dbj := collection("users")[ $$.name = "Deadbeat Jim" ]
         return insert { "status" : "credit card declined" } into $dbj
      :)

      let $dbj := $users[?name = "Deadbeat Jim"]
      return $dbj => map:put("status", "credit card declined")
      
      </test>
      <result>
         <assert-deep-eq>{
           "name" : "Deadbeat Jim",
           "address" : "1 E 161st St, Bronx, NY 10451",
           "status" : "credit card declined",
           "risk tolerance" : "high"
         }</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="JSONiq-1.1.5">
      <description>Data Transformations</description>
      <created by="Michael Kay" on="2025-08-13"/>
      <dependency type="spec" value="XQ40+ XP40+"/>      
      <test>
         (: XQ 4.0 solution requires deep update :)
         let $feed := 
         {
    "encoding" : "UTF-8",
    "feed" : {
        "author" : [
            {
                "name" : {
                    "$t" : "YouTube"
                },
                "uri" : {
                    "$t" : "http://www.youtube.com/"
                }
            }
        ],
        "category" : [
            {
                "scheme" : "http://schemas.google.com/g/2005#kind",
                "term" : "http://gdata.youtube.com/schemas/2007#video"
            }
        ],
        "entry" : [
            {
                "app$control" : {
                    "yt$state" : {
                        "$t" : "Syndication of this video was restricted by its owner.",
                        "name" : "restricted",
                        "reasonCode" : "limitedSyndication"
                    }
                },
                "author" : [
                    {
                        "name" : {
                            "$t" : "beyonceVEVO"
                        },
                        "uri" : {
                            "$t" : "http://gdata.youtube.com/feeds/api/users/beyoncevevo"
                        }
                    }
                ]
                }]
         } } return
         (: JSONiq;
               copy $out := $feed
              modify
                 let $feed := $out.feed
                 let $feed-entry := $feed.entry
                 for $entry at $pos in $feed-entry[]
                 where $entry."app$control"."yt$state".name eq "restricted"
                 return delete $feed-entry.pos
              return $out 
         :)     
         true() (: TBA :)
      </test>
      <result>
         <assert-true/>
      </result>
   </test-case>
   
   
   
   
   {
    "encoding" : "UTF-8",
    "feed" : {
        "author" : [
            {
                "name" : {
                    "$t" : "YouTube"
                },
                "uri" : {
                    "$t" : "http://www.youtube.com/"
                }
            }
        ],
        "category" : [
            {
                "scheme" : "http://schemas.google.com/g/2005#kind",
                "term" : "http://gdata.youtube.com/schemas/2007#video"
            }
        ],
        "entry" : [
            {
                "app$control" : {
                    "yt$state" : {
                        "$t" : "Syndication of this video was restricted by its owner.",
                        "name" : "restricted",
                        "reasonCode" : "limitedSyndication"
                    }
                },
                "author" : [
                    {
                        "name" : {
                            "$t" : "beyonceVEVO"
                        },
                        "uri" : {
                            "$t" : "http://gdata.youtube.com/feeds/api/users/beyoncevevo"
                        }
                    }
                ]
!!! SNIP !!!
The following query creates a modified copy of the feed by removing all entries that restrict syndication.
let $feed := collection("youtube")
return
   copy $out := $feed
   modify
      let $feed := $out.feed
      let $feed-entry := $feed.entry
      for $entry at $pos in $feed-entry[]
      where $entry."app$control"."yt$state".name eq "restricted"
      return delete $feed-entry.pos
   return $out
   

   
</test-set>
