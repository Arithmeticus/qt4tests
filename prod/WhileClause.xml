<?xml version="1.0" encoding="us-ascii"?>
<test-set xmlns="http://www.w3.org/2010/09/qt-fots-catalog" name="prod-WhileClause" covers-40="PR943">
   <description>Tests for the WhileClause production in 4.0</description>
   
   <environment name="fsx">
      <source role="." file="ForClause/fsx.xml">
         <description>Data about a filesystem represented in XML.</description>
         <created by="Mike Rorke" on="2003-03-25"/>
      </source>    
   </environment>
   
   <dependency type="spec" value="XQ40+"/>

   <test-case name="WhileExpr001">
      <description> For+While+Return - test existence of child elements in While clause </description>
      <created by="Jinghao Liu" on="2003-02-10"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <environment ref="fsx"/>
      <test><![CDATA[if ( count( for $f in //* while $f/File return $f/File[1] ) = count( //File[1]) ) then <Same/> else <notSame/>]]></test>
      <result>
         <assert-xml><![CDATA[<notSame />]]></assert-xml>
      </result>
   </test-case>

   <test-case name="WhileExpr002">
      <description> For+While+Return - error, variable in 'While' Expr hasn't been defined </description>
      <created by="Jinghao Liu" on="2003-02-10"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <environment ref="fsx"/>
      <test><![CDATA[for $folder in //Folder while $folde/@name = "ABC" return <folder/>]]></test>
      <result>
         <error code="XPST0008"/>
      </result>
   </test-case>

   <test-case name="WhileExpr003">
      <description> For+While+Return - using same predicate (as FLWOR003) in 'While' predicate </description>
      <created by="Jinghao Liu" on="2003-02-10"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <environment ref="fsx"/>
      <test><![CDATA[for $d in /MyComputer/Drive4 while $d/Folder[@id="128"] return <FolderName>{$d/Folder/@name}</FolderName>]]></test>
      <result>
         <assert-xml><![CDATA[<FolderName name="Folder00000000047" />]]></assert-xml>
      </result>
   </test-case>

   <test-case name="WhileExpr004">
      <description> For+While+Return - filters in 'While' expr and in 'In' expr using predicate </description>
      <created by="Jinghao Liu" on="2003-02-10"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <environment ref="fsx"/>
      <test>for $f in /MyComputer/Drive1/Folder[@creator="Mani"]/File while $f/@creation_date="08/06/00" return $f</test>
      <result>
         <assert-xml><![CDATA[<File creation_date="08/06/00" creator="Leon" name="File00000000000" type="FileType" idref="1" id="2">
				<FileName>File00000000000</FileName>
				<description> abides fullest charms aprons batter perspective brags yesterday honor bluest<bold> wills crimeful calm lobby truer miser perseus take</bold> tapers owe ceas rhyme mindful surly suspect fantasticoes spirits legitimation holofernes portraiture trouts suffocating deed strides ithaca<bold> smiles sunshine loud right disdainfully figs searching</bold> curl reins humble nurture hue doom hidden abridgement seein<bold> invisible authentic shapes quae several reaches howled</bold> merry purpos howl burneth scholars untreasur maidenliest dealing</description>
				<SecurityObject name="so00000000001">
					<Denies>
						<Deny>
							<security/>
							<user>system\Changyuan</user>
						</Deny>
						<Deny>
							<security>
								<right>Read</right>
							</security>
							<user>system\Toshiko</user>
						</Deny>
					</Denies>
					<Allows>
						<Allow>
							<security>
								<right>Read</right>
								<right>Write</right>
							</security>
							<user>system\Hyungjeong</user>
						</Allow>
					</Allows>
				</SecurityObject>
				<Stream binary="false" streamid="1" content-type="text/xml" size="1001.33" name="sample.xml" type="StreamType">
					<StreamType>StreamType</StreamType>
					<StreamSize>1001.33</StreamSize>
					<StreamID>1</StreamID>
					<Binary>false</Binary>
					<Summary>This value is constant</Summary>
				</Stream>
			</File>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="WhileExpr005">
      <description> For+While+Return - use always-false-predicate in 'While' expr </description>
      <created by="Jinghao Liu" on="2003-02-10"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <environment ref="fsx"/>
      <test><![CDATA[<empty> { for $folder in /MyComputer/Drive2//Folder while 1 = 2 return <Folder> { $folder/FolderName/text() } </Folder> } </empty>]]></test>
      <result>
         <any-of>
            <assert-xml><![CDATA[<empty/>]]></assert-xml>
            <error code="XPST0005"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="WhileExpr006">
      <description> For+While+Return - In the inner For+While+Return, uses outer variable in 'While' expr </description>
      <created by="Jinghao Liu" on="2003-02-10"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <modified by="Gunther Rademacher" on="2025-03-04" change="Make test independent of boundary space in result"/>
      <environment ref="fsx"/>
      <test><![CDATA[
         for $folder in /MyComputer/Drive4//Folder 
         return <Folder>{ $folder/@name }{ 
            for $file in /MyComputer/Drive4//File 
            while $file/@idref = $folder/@id 
            return <File>{ $file/@name }</File> }</Folder>
      ]]></test>
      <result>
         <assert-xml><![CDATA[<Folder name="Folder00000000047"/><Folder name="Folder00000000048"><File name="File00000000077"/><File name="File00000000078"/><File name="File00000000079"/><File name="File00000000080"/><File name="File00000000081"/></Folder><Folder name="Folder00000000049"/><Folder name="Folder00000000050"/><Folder name="Folder00000000051"/><Folder name="Folder00000000052"/><Folder name="Folder00000000053"/><Folder name="Folder00000000054"/>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="WhileExpr007">
      <description> For+While+Return - 2 iterations use 'While' to build relationship </description>
      <created by="Jinghao Liu" on="2003-02-10"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <modified by="Gunther Rademacher" on="2025-03-04" change="Make test independent of boundary space in result"/>
      <environment ref="fsx"/>
      <test><![CDATA[<fragment-result>{ for $folder in /MyComputer/Drive3/Folder ,$file in /MyComputer/Drive3/Folder/File while $folder/@id = $file/@idref return <Folder> { $folder/@name, $folder/@id } <file>{ $file/@idref, $file/FileName/text() }</file> </Folder> }</fragment-result>]]></test>
      <result>
         <assert-xml><![CDATA[<fragment-result><Folder name="Folder00000000017" id="67"><file idref="67">File00000000047</file></Folder></fragment-result>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="WhileExpr008">
      <description> Test 'while' expression with the empty sequence literal </description>
      <created by="Mike Rorke" on="2005-06-24"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <environment ref="fsx"/>
      <test><![CDATA[<empty> { for $file in (//Folder)[1]/File while () return $file/FileName } </empty>]]></test>
      <result>
         <any-of>
            <assert-xml><![CDATA[<empty/>]]></assert-xml>
            <error code="XPST0005"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="WhileExpr009">
      <description> Test 'while' expression returning a sequence with one or more nodes </description>
      <created by="Mike Rorke" on="2005-06-24"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <environment ref="fsx"/>
      <test>for $file in (//Folder)[1]/File while $file/SecurityObject/Denies/Deny/security/right return $file/FileName</test>
      <result>
         <assert-xml><![CDATA[<FileName>File00000000000</FileName>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="WhileExpr010">
      <description> Test 'while' expression returning a sequence with multiple values </description>
      <created by="Mike Rorke" on="2005-06-24"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <environment ref="fsx"/>
      <test>for $file in (//Folder)[1]/File while data( $file/SecurityObject//right ) return $file/FileName</test>
      <result>
         <error code="FORG0006"/>
      </result>
   </test-case>

   <test-case name="WhileExpr013">
      <description> Test 'while' expression returning a sequence with a single boolean value </description>
      <created by="Mike Rorke" on="2005-06-24"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <environment ref="fsx"/>
      <test>for $file in (//Folder)[1]/File while $file/SecurityObject/Denies/Deny/security/right="Change" return $file/FileName</test>
      <result>
         <assert-empty/>
      </result>
   </test-case>

   <test-case name="WhileExpr014">
      <description> Test 'while' expression returning a sequence with a constant boolean value </description>
      <created by="Mike Rorke" on="2005-06-24"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <environment ref="fsx"/>
      <test>for $file in (//Folder)[1]/File while true() return $file/FileName</test>
      <result>
         <assert-xml><![CDATA[<FileName>File00000000000</FileName><FileName>File00000000001</FileName><FileName>File00000000002</FileName><FileName>File00000000003</FileName><FileName>File00000000004</FileName><FileName>File00000000005</FileName><FileName>File00000000006</FileName><FileName>File00000000007</FileName><FileName>File00000000008</FileName><FileName>File00000000009</FileName><FileName>File00000000010</FileName><FileName>File00000000011</FileName><FileName>File00000000012</FileName><FileName>File00000000013</FileName><FileName>File00000000014</FileName><FileName>File00000000015</FileName><FileName>File00000000016</FileName><FileName>File00000000017</FileName><FileName>File00000000018</FileName><FileName>File00000000019</FileName><FileName>File00000000020</FileName><FileName>File00000000021</FileName><FileName>File00000000022</FileName><FileName>File00000000023</FileName><FileName>File00000000024</FileName><FileName>File00000000025</FileName><FileName>File00000000026</FileName><FileName>File00000000027</FileName><FileName>File00000000028</FileName><FileName>File00000000029</FileName><FileName>File00000000030</FileName>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="WhileExpr015">
      <description> Test 'while' expression returning a sequence with a constant boolean value </description>
      <created by="Mike Rorke" on="2005-06-24"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <environment ref="fsx"/>
      <test><![CDATA[<empty> { for $file in (//Folder)[1]/File while false() return $file/FileName } </empty>]]></test>
      <result>
         <any-of>
            <assert-xml><![CDATA[<empty/>]]></assert-xml>
            <error code="XPST0005"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="WhileExpr016">
      <description> Test 'while' clause based on a positional variable </description>
      <created by="Mike Rorke" on="2005-06-24"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <environment ref="fsx"/>
      <test>for $file at $offset in (//Folder)[1]/File while $offset mod 2 = 1 return $file/FileName</test>
      <result>
         <assert-xml><![CDATA[<FileName>File00000000000</FileName>]]></assert-xml>
      </result>
   </test-case>

   <test-case name="WhileExpr017">
      <description> Attempt to use multiple expressions in a 'while' clause </description>
      <created by="Mike Rorke" on="2005-06-24"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <environment ref="fsx"/>
      <test>for $file in (//Folder)[1]/File while true(), true() return $file/FileName</test>
      <result>
         <error code="XPST0003"/>
      </result>
   </test-case>

   <test-case name="WhileExpr018">
      <description> Use of undefined variable in 'while' clause </description>
      <created by="Mike Rorke" on="2005-06-24"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <environment ref="fsx"/>
      <test>for $file in (//Folder)[1]/File while $undefined return $file/FileName</test>
      <result>
         <error code="XPST0008"/>
      </result>
   </test-case>

   <test-case name="WhileExpr019">
      <description> Typo on 'while' clause </description>
      <created by="Mike Rorke" on="2005-06-24"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <environment ref="fsx"/>
      <test>for $file in (//Folder)[1]/File while_ true() return $file/FileName</test>
      <result>
         <error code="XPST0003"/>
      </result>
   </test-case>

   <test-case name="WhileExpr020">
      <description> Multiple 'while' clauses (XQuery 1.0)</description>
      <created by="Mike Rorke" on="2005-06-24"/>
      <modified by="Michael Kay" on="2011-07-30" change="add XQuery 1.0 dependency"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <environment ref="fsx"/>
      <dependency type="spec" value="XQ10"/>
      <test>for $file in (//Folder)[1]/File while true() while false() return $file/FileName</test>
      <result>
        <error code="XPST0003"/>
      </result>
   </test-case>
   
   <test-case name="WhileExpr020a" covers-30="flwor-generalization">
      <description> Multiple 'while' clauses (XQuery 3,0)</description>
      <created by="Mike Rorke" on="2005-06-24"/>
      <modified by="Michael Kay" on="2011-07-30" change="add XQuery 3.0 dependency"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <environment ref="fsx"/>
      <test>for $file in (//Folder)[1]/File while true() while false() return $file/FileName</test>
      <result>
         <assert-empty/>
      </result>
   </test-case>
   
   <test-case name="WhileExpr021">
      <description> Check that context item is NOT changed when evaluating the while clause</description>
      <created by="Michael Kay" on="2011-07-30"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <environment ref="fsx"/>
      <dependency type="spec" value="XQ10"/>
      <test>for $file in (//Folder)[1]/File while (. instance of element(File)) return $file/FileName</test>
      <result>
        <assert-empty/>
      </result>
   </test-case>
   
   <test-case name="WhileExpr022">
      <description> Composite while clause depending on multiple variables </description>
      <created by="Michael Kay" on="2011-09-01"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <environment ref="fsx"/>
      <test>
         for $file in //File 
         let $namelen := string-length($file/FileName)
         while ($namelen = 15 and $file//Allow/user = 'system\Hyungjeong') 
         return $file/FileName
      </test>
      <result>
         <assert-string-value>File00000000000</assert-string-value>
      </result>
   </test-case>
   
   <test-case name="WhileExpr023" covers-30="flwor-generalization">
      <description> While clause appearing after a count clause </description>
      <created by="Michael Kay" on="2011-09-01"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <environment ref="fsx"/>
      <test>
         for $file in //File
         count $c
         while ($file//Allow/user != 'system\Aladin') 
         return $c
      </test>
      <result>
         <assert-string-value>1</assert-string-value>
      </result>
   </test-case>
   
   <test-case name="WhileExpr024" covers-30="flwor-generalization">
      <description> Multiple while clauses in suboptimal order </description>
      <created by="Michael Kay" on="2011-09-01"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <environment ref="fsx"/>
      <test>
         for $file in //File 
         let $prefix := substring($file/FileName, 1, 4)
         while ($prefix = 'File')
         while ($file//Allow/user = 'system\Hyungjeong')
         return $file/FileName
      </test>
      <result>
         <assert-string-value>File00000000000</assert-string-value>
      </result>
   </test-case>
   
   <test-case name="WhileExpr025" covers-30="flwor-generalization">
      <description> While clause with no dependencies on FLWOR variables </description>
      <created by="Michael Kay" on="2011-09-01"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <environment ref="fsx"/>
      <test>
         for $file in //File 
         while current-date() gt xs:date('1900-01-01')
         let $prefix := substring($file/FileName, 1, 4)
         while ($prefix = 'File')
         while ($file//Allow/user = 'system\Hyungjeong')
         return $file/FileName
      </test>
      <result>
         <assert-string-value>File00000000000</assert-string-value>
      </result>
   </test-case>
   
   <test-case name="WhileExpr026" covers-30="flwor-generalization">
      <description> While clause that depends on position() </description>
      <created by="Michael Kay" on="2011-09-01"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <environment ref="fsx"/>
      <test>
         let $doc := (/)
         return (11 to 15)!
            (for $file in $doc//File
            count $c
            while $c = position()
            return $file/FileName)
      </test>
      <result>
         <assert-string-value>File00000000000</assert-string-value>
      </result>
   </test-case>
   
   <test-case name="WhileExpr027" covers-30="flwor-generalization">
      <description> While clause that depends on last() </description>
      <created by="Michael Kay" on="2011-09-01"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <environment ref="fsx"/>
      <test>
         let $doc := (/)
         return (11 to 15)!
            (for $file at $c in $doc//File
            while $c = last()
            return string($file/FileName))
      </test>
      <result>
         <assert-string-value></assert-string-value>
      </result>
   </test-case>
   
   <test-case name="WhileExpr028">
      <description> While clause with let (and no for) </description>
      <created by="Michael Kay" on="2011-09-01"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>
         let $x := 1 to 10
         while $x = 1
         return $x
      </test>
      <result>
         <assert-string-value>1 2 3 4 5 6 7 8 9 10</assert-string-value>
      </result>
   </test-case>
   
   <test-case name="WhileExpr029">
      <description> While clause with let (and no for) </description>
      <created by="Michael Kay" on="2011-09-01"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>
         let $x := 1 to 10
         while count($x) = 1
         return $x
      </test>
      <result>
         <assert-empty/>
      </result>
   </test-case>
   
   <test-case name="WhileExpr030" covers-30="allowing-empty">
      <description> While clause with "outer for" </description>
      <created by="Michael Kay" on="2011-09-01"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>
         declare variable $n external := 10;
         for $x allowing empty in 1 to $n
         while $x lt 5
         return $x
      </test>
      <result>
         <assert-string-value>1 2 3 4</assert-string-value>
      </result>
   </test-case>
   
   <test-case name="WhileExpr031" covers-30="allowing-empty">
      <description> While clause with "outer for" </description>
      <created by="Michael Kay" on="2011-09-01"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>
         declare variable $n external := 0;
         for $x allowing empty in 1 to $n
         while not($x = 5)
         return concat("[", $x, "]")
      </test>
      <result>
         <assert-string-value>[]</assert-string-value>
      </result>
   </test-case>
   
   <test-case name="WhileExpr032" covers-30="allowing-empty">
      <description> While clause with "outer for". A trap for systems that rewrite while clauses as predicates. </description>
      <created by="Michael Kay" on="2011-09-01"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>
         for $x allowing empty in 1 to 5
         while $x lt 0
         return empty($x)
      </test>
      <result>
         <assert-empty/>
      </result>
   </test-case>
   
   <test-case name="WhileExpr033" covers-30="default-external-var">
      <description> Integer-valued while clause. A trap for systems that rewrite while clauses as predicates. </description>
      <created by="Michael Kay" on="2011-09-01"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>
         declare variable $n external := 0;
         for $x in -2 to +2
         while ($n - $x)
         return $x
      </test>
      <result>
         <assert-string-value>-2 -1</assert-string-value>
      </result>
   </test-case>
   
   <test-case name="WhileExpr034" covers-30="default-external-var">
      <description>A while clause that doesn't depend on the previous for clause (Saxon optimisation bug 4765)</description>
      <created by="Michael Kay" on="2020-09-29"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>
         for $i in 1 to 10
         for $j in 10 to 14
         while $i lt 5
         return if ($i mod 2 eq 1) then $i + $j else ()
      </test>
      <result>
         <assert-string-value>11 12 13 14 15 13 14 15 16 17</assert-string-value>
      </result>
   </test-case>
   
   <test-case name="WhileExpr035" covers-30="default-external-var">
      <description>Alternative way of writing WhileExpr034 that triggers Saxon optimisation bug 4765</description>
      <created by="Michael Kay" on="2020-09-29"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>
         for $i in 1 to 10
         return 
            for $j in 10 to 14
            return if ($i lt 5 and $i mod 2 eq 1) then $i + $j else ()
      </test>
      <result>
         <assert-string-value>11 12 13 14 15 13 14 15 16 17</assert-string-value>
      </result>
   </test-case>

   <test-case name="whileClause-1">
      <description> use of while clause involving an "or" expression. Use fn:true() </description>
      <created by="Carmelo Montanez" on="2005-11-18"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>let $var := (fn:true()) while $var or fn:true() return $var or fn:true()</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="whileClause-2">
      <description> use of while clause involving an "or" expression. Use fn:false() Use fn:not() </description>
      <created by="Carmelo Montanez" on="2005-11-18"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>let $var := (fn:false()) while fn:not($var or fn:false()) return $var or fn:false()</test>
      <result>
         <assert-false/>
      </result>
   </test-case>

   <test-case name="whileClause-3">
      <description> use of while clause involving an "or" ("and" operator) expression. Use fn:true() </description>
      <created by="Carmelo Montanez" on="2005-11-18"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>let $var := (fn:true()) while $var and fn:true() return $var and fn:true()</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="whileClause-4">
      <description> use of while clause involving an "or" ("and" operator) expression. Use fn:false() Use fn:not() </description>
      <created by="Carmelo Montanez" on="2005-11-18"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>let $var := (fn:false()) while fn:not($var and fn:false()) return $var and fn:false()</test>
      <result>
         <assert-false/>
      </result>
   </test-case>

   <test-case name="whileClause-5">
      <description> use of while clause with a typeswitch expression </description>
      <created by="Carmelo Montanez" on="2005-11-18"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>let $var := 100 while typeswitch($var) case $i as xs:string return fn:false() case $i as xs:integer return fn:true() default return fn:false() return $var</test>
      <result>
         <assert-eq>100</assert-eq>
      </result>
   </test-case>

   <test-case name="whileClause-6">
      <description> use of while clause used with a string value and fn:string </description>
      <created by="Carmelo Montanez" on="2005-11-18"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>let $var := "String" while fn:string($var) = "String" return $var</test>
      <result>
         <assert-string-value>String</assert-string-value>
      </result>
   </test-case>

   <test-case name="whileClause-7">
      <description> use of while clause used with a string-length function. </description>
      <created by="Carmelo Montanez" on="2005-11-18"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>let $var := "String" while fn:string-length($var) = 6 return fn:string-length($var)</test>
      <result>
         <assert-eq>6</assert-eq>
      </result>
   </test-case>

   <test-case name="whileClause-8">
      <description> use of while clause used with a fn:count() function. </description>
      <created by="Carmelo Montanez" on="2005-11-18"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>let $var := 100 while fn:count(($var)) = 1 return fn:count(($var))</test>
      <result>
         <assert-eq>1</assert-eq>
      </result>
   </test-case>

   <test-case name="whileClause-9">
      <description> use of while clause used with is comparator. </description>
      <created by="Carmelo Montanez" on="2005-11-18"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test><![CDATA[let $var := <anElement>Some content</anElement> while $var is $var return $var is $var]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="whileClause-10">
      <description> use of while clause used with quantified expression (some keyword). </description>
      <created by="Carmelo Montanez" on="2005-11-18"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>
         let $var := 1 
         while some $x in (1, 2) satisfies fn:string($var) = "1" 
         return fn:string($var )</test>
      <result>
         <assert-string-value>1</assert-string-value>
      </result>
   </test-case>

   <test-case name="whileClause-11">
      <description> use of while clause used with quantified expression (every keyword). </description>
      <created by="Carmelo Montanez" on="2005-11-18"/>
      <test>
         let $var := 1 
         while every $x in (1, 1) satisfies fn:string($var) = "1" 
         return fn:string($var )</test>
      <result>
         <assert-string-value>1</assert-string-value>
      </result>
   </test-case>
   
   <test-case name="whileClause-12">
      <description>A Saxon optimization bug - #4870</description>
      <created by="Michael Kay after Christian Gruen" on="2021-01-07"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>
         let $seq := (1, reverse(1 to 2))
         for $item in distinct-values($seq)
         while count($seq[. = $item]) > 1
         return $item
      </test>
      <result>
         <assert-eq>1</assert-eq>
      </result>
   </test-case>

   <test-case name="K-WhileExpr-1">
      <description> A for/while combination while the cardinality of the return statement is crucially affected by the binding sequence. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>(for $fo in (1, 2, 3) while $fo eq 1 return $fo)</test>
      <result>
         <assert-eq>1</assert-eq>
      </result>
   </test-case>

   <test-case name="K-WhileExpr-2">
      <description> Get the string value of the return statement of a for expression after being filtered by a while clause. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>string(exactly-one((for $fo in (1, 2, 3) while $fo eq 1 return $fo)))</test>
      <result>
         <assert-string-value>1</assert-string-value>
      </result>
   </test-case>

   <test-case name="K-WhileExpr-3">
      <description> A while clause containing a value which EBV cannot be extracted from. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>count((for $fo in (1, 2, 3) while xs:time("08:08:23Z") return $fo)) eq 3</test>
      <result>
         <error code="FORG0006"/>
      </result>
   </test-case>

   <test-case name="K-WhileExpr-4">
      <description> A for/while expression combined with fn:count(). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>for $i in 1 while count(($i, 2, timezone-from-time(current-time()))) return true()</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-WhileExpr-5">
      <description> A for expression binding to one single value, combined with a positive while clause. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>empty(for $i in 1 while false() return $i)</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-WhileExpr-6">
      <description> A for expression binding to one single value, combined with a negative while clause. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>(for $i in 1 while true() return $i) eq 1</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-WhileExpr-7">
      <description> A for expression binding to one single value, combined with a positive while clause. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>empty(for $i in 1 while (1, current-time())[1] treat as xs:integer eq 0 return $i)</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-WhileExpr-8">
      <description> A for expression binding to one single value, combined with a negative while clause. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>(for $i in 1 while (1, current-time())[1] treat as xs:integer eq 1 return $i) eq 1</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-WhileExpr-9">
      <description> A for/while expression combined with fn:boolean. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>for $i in (1, 2, current-time())[1] while fn:boolean($i treat as xs:integer) return true()</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-WhileExpr-10">
      <description> A for/while expression combined with fn:boolean and xs:anyURI. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>for $i in (1, 2, current-time())[1] while xs:anyURI("example.com/") return true()</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-WhileExpr-11">
      <description> A for/while expression combined with fn:boolean and xs:anyURI. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>empty(for $i in (1, 2, current-time())[1] while xs:anyURI("") return true())</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K2-WhileExpr-1">
      <description> Multiple while clauses is not allowed in XQuery 1.0. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <modified by="Michael Dyck" on="2011-09-05" change="Split off XQuery 3.0 expectation (to K2-WhileExpr-1b)"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <dependency type="spec" value="XQ10"/>
      <test>for $a in 1 while true() while true() return $a</test>
      <result>
         <error code="XPST0003"/>
      </result>
   </test-case>

   <test-case name="K2-WhileExpr-1b" covers-30="flwor-generalization">
      <description> Multiple while clauses are allowed in XQuery 3.0. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <modified by="Michael Dyck" on="2011-09-05" change="Split off XQuery 3.0 expectation (from K2-WhileExpr-1)"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>for $a in 1 while true() while true() return $a</test>
      <result>
         <assert-eq>1</assert-eq>
      </result>
   </test-case>

   <test-case name="K2-WhileExpr-2">
      <description> Multiple while clauses is not allowed(#2). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>for $a in 1 while true(), true() return $a</test>
      <result>
         <error code="XPST0003"/>
      </result>
   </test-case>
   
   
   <test-case name="cbcl-while-hash-join-1">
      <description> A query that can be optimized down to a hash join - testing that the implicit cast-operand is emulated correctly </description>
      <created by="Oliver Hallam" on="2008-01-04"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>for $x in (xs:untypedAtomic("123"), xs:untypedAtomic("234")) for $y in (xs:string("123"), xs:float(123), xs:double(123)) while $x = $y return $x</test>
      <result>
         <any-of>
            <assert-string-value>123 123 123</assert-string-value>
            <error code="XPST0004"/>
         </any-of>
      </result>
   </test-case>
   

   <test-case name="cbcl-while-hash-join-2">
      <description> A query that can be optimized down to a hash join - with integer types. </description>
      <created by="Oliver Hallam" on="2008-01-04"/>      
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>for $x in (xs:integer("123"), xs:integer("234")) for $y in (xs:integer("123"), xs:integer("456")) while $x = $y return $x</test>
      <result>
         <assert-string-value>123</assert-string-value>
      </result>
   </test-case>
   

   <test-case name="cbcl-while-hash-join-3">
      <description> A query that can be optimized down to a hash join - with date types of varying timezones</description>
      <created by="Oliver Hallam" on="2008-01-04"/>      
      <modified by="Tim Mills" on="2013-07-04" change="Made timezone-independent.  See Bug 21222." />
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>for $x in (xs:date("2010-10-10"), xs:date("1997-01-01+12:00"), xs:date("1997-01-02+12:00")) for $y in (adjust-date-to-timezone(xs:date("2010-10-10"), implicit-timezone()), xs:date("1997-01-01-12:00")) while $x = $y return $x</test>
      <result>
         <assert-string-value>2010-10-10</assert-string-value>
      </result>
   </test-case>
   

   <test-case name="cbcl-while-hash-join-4">
      <description> A query that can be optimized down to a hash join - with a mixture of untypedAtomics and doubles. </description>
      <created by="Oliver Hallam" on="2008-01-04"/>      
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>for $x in (xs:untypedAtomic("2.0"), xs:untypedAtomic("3"), xs:double("3.0")) for $y in (xs:untypedAtomic("2"), xs:untypedAtomic("3"), xs:double("3")) while $x = $y return $x</test>
      <result>
         <assert-string-value/>
      </result>
   </test-case>
   

   <test-case name="cbcl-while-hash-join-005">
      <description> Test tricky hash-join implicit conversion case. </description>
      <created by="Oliver Hallam" on="2008-06-02"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <dependency type="spec" value="XQ10+"/>      
      <test>declare function local:durationOrFloat($i as xs:integer) { 
               (xs:float(123), xs:float(234), xs:duration("P1D"))[$i] 
            }; 
            for $x in (xs:untypedAtomic("123"), xs:untypedAtomic("234")) 
            for $y in (for $z in (1,2) 
                       return local:durationOrFloat($z)) 
            while $x = $y 
            return $x</test>
      <result>
         <assert-string-value>123</assert-string-value>
      </result>
   </test-case>
   

   <test-case name="cbcl-while-product-001">
      <description> Test products which return empty sequence </description>
      <created by="Tim Mills" on="2008-07-11"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <dependency type="spec" value="XQ10+"/>      
      <test>declare function local:odds($arg as xs:integer*) as xs:integer* { $arg[. mod 2 eq 1] }; boolean(zero-or-one(for $x in local:odds((2,4,8)),$y in local:odds((2,4,8)) return ($x,$y)))</test>
      <result>
         <assert-false/>
      </result>
   </test-case>
   

   <test-case name="cbcl-while-set-from-optional-item-001">
      <description> Tests set from optional item returning empty sequence </description>
      <created by="Tim Mills" on="2008-07-11"/>      
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test><![CDATA[declare function local:odds($arg as xs:integer?) as xs:integer? { $arg[. mod 2 eq 1] }; boolean(for $x in local:odds(2) while $x < 3 return $x + 1)]]></test>
      <result>
         <assert-false/>
      </result>
   </test-case>
   

   <test-case name="cbcl-while-hash-join-006">
      <description> Test a hash join that produces a dynamic type check error </description>
      <created by="Oliver Hallam" on="2008-07-14"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <dependency type="spec" value="XQ10+"/>     
      <test>declare function local:sequence($arg as xs:integer) as item()* { if ($arg mod 2 eq 0) then (1, 3, 5, 7, 9) else ("a", "b", "c") }; for $x in local:sequence(2) for $y in local:sequence(3) while $x = $y return ($x, $y)</test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>
   

   <test-case name="cbcl-while-hash-join-007">
      <description> Test a hash join that produces a static type check error, but is fine in dynamic mode </description>
      <created by="Oliver Hallam" on="2008-07-14"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <dependency type="spec" value="XQ10+"/>      
      <test>declare function local:sequence($arg as xs:integer) as item()* { if ($arg mod 2 eq 0) then (1, 3, 5, 7, 9) else ("a", "b", "c") }; for $x in local:sequence(2) for $y in local:sequence(2) while $x = $y return ($x, $y)</test>
      <result>
         <assert-string-value>1 1</assert-string-value>
      </result>
   </test-case>
   

   <test-case name="cbcl-while-hash-join-008">
      <description> Test a hash join that casts untypedAtomic values to multiple types </description>
      <created by="Oliver Hallam" on="2008-07-14"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <dependency type="spec" value="XQ10+"/>      
      <test>declare function local:sequence($arg as xs:integer) as item()* { if ($arg mod 2 eq 0) then (1, 3, 5, 7, 9, "cheese") else (xs:untypedAtomic("1"), xs:untypedAtomic("2")) }; for $x in local:sequence(2) for $y in local:sequence(3) while $x = $y return ($x, $y)</test>
      <result>
         <assert-string-value>1 1</assert-string-value>
      </result>
   </test-case>
   

   <test-case name="cbcl-while-hash-join-009">
      <description> Test a hash join with type error </description>
      <created by="Oliver Hallam" on="2008-07-14"/>      
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>for $x in (1,2,3,"cheese") for $y in (1,2,3,"cheese") while $x = $y return ($x, $y)</test>
      <result>
         <assert-string-value>1 1</assert-string-value>
      </result>
   </test-case>
   

   <test-case name="cbcl-while-hash-join-010">
      <description> Test hash-join requiring untypedAtomic casting, with a type error. </description>
      <created by="Oliver Hallam" on="2008-07-14"/>      
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>for $x in (1,2,3, xs:untypedAtomic("1")) for $y in (1,2,3,"cheese") while $x = $y return ($x, $y)</test>
      <result>
         <assert-string-value>1 1</assert-string-value>
      </result>
   </test-case>
   

   <test-case name="cbcl-while-group-by-key-001">
      <description> Test producing a group-by-key expression </description>
      <created by="Oliver Hallam" on="2008-07-11"/>      
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test><![CDATA[declare function local:get-words() { tokenize("she sells sea shells by the sea shore", "\s+") }; let $words := local:get-words() let $distinct-words := distinct-values($words) for $word in $distinct-words return <word word="{$word}" count="{count($words[. = $word])}" />]]></test>
      <result>
         <assert-xml>&lt;word word="she" count="1"/&gt;&lt;word word="sells" count="1"/&gt;&lt;word word="sea" count="2"/&gt;&lt;word word="shells" count="1"/&gt;&lt;word word="by" count="1"/&gt;&lt;word word="the" count="1"/&gt;&lt;word word="shore" count="1"/&gt;</assert-xml>
      </result>
   </test-case>
   

   <test-case name="cbcl-while-group-by-key-002">
      <description> A variant on group-by-key that does not involve a left outer join </description>
      <created by="Oliver Hallam" on="2008-07-11"/>      
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>let $items := for $x in 1 to 100 return $x mod 10, $distinct-items := distinct-values($items) for $dist in $distinct-items, $item in $items while $item = $dist return $item</test>
      <result>
         <assert-string-value>1</assert-string-value>
      </result>
   </test-case>
   

   <test-case name="cbcl-while-group-by-key-003">
      <description> A group-by-key that has to be careful about errors </description>
      <created by="Oliver Hallam" on="2008-07-11"/>      
      <modified by="Tim Mills" on="2016-07-29" change="remove dependency on number of digits used to represent xs:decimal" />      
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>let $items := for $x in 1 to 100 return $x mod 10, $distinct-items := distinct-values($items) for $dist in $distinct-items return min( if ($dist = 0) then 0 else for $item in $items while $item = $dist return fn:round(1000 div $item))</test>
      <result>
         <assert-string-value>1000 0</assert-string-value>
      </result>
   </test-case>
   

   <test-case name="cbcl-while-group-by-key-004">
      <description> A group by that has to be careful about errors </description>
      <created by="Oliver Hallam" on="2008-07-11"/>      
      <modified by="Tim Mills" on="2016-07-29" change="remove dependency on number of digits used to represent xs:decimal" />      
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>let $items := for $x in 1 to 100 return $x mod 10, $distinct-items := distinct-values($items) for $dist in $distinct-items return min( for $item in $items while $item = $dist return if ($dist = 0) then 0 else fn:round(1000 div $item))</test>
      <result>
         <assert-string-value>1000</assert-string-value>
      </result>
   </test-case>
   

   <test-case name="cbcl-while-left-outer-join-001">
      <description> A left outer join with some tricky error avoidance </description>
      <created by="Oliver Hallam" on="2008-07-15"/>      
      <modified by="Tim Mills" on="2016-07-29" change="remove dependency on number of digits used to represent xs:decimal" />      
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test>let $items := for $x in 1 to 100 return $x mod 10, $distinct-items := for $y in 1 to (count($items) idiv 10) return $y mod 10 for $dist in $distinct-items return if ($dist = 0) then 0 else min( for $item in $items while $item = $dist return fn:round(1000 div $item))</test>
      <result>
         <assert-string-value>1000 0</assert-string-value>
      </result>
   </test-case>
   

   <test-case name="cbcl-while-hash-join-011">
      <description> Test a hash join with sequences for keys </description>
      <created by="Oliver Hallam" on="2008-07-16"/>      
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test><![CDATA[for $x in <t><r><d>1</d><d>1</d><d>1</d></r><r><d>1</d><d>2</d><d>3</d></r><r><d>2</d><d>3</d><d>4</d></r></t>/r, $y in <t><r><d>1</d><d>1</d><d>1</d></r><r><d>2</d><d>4</d><d>6</d></r><r><d>3</d><d>2</d><d>1</d></r></t>/r while $x/d/string(.) = $y/d/string(.) return concat($x, '=', $y)]]></test>
      <result>
         <assert-string-value>111=111</assert-string-value>
      </result>
   </test-case>
   

   <test-case name="cbcl-while-map-concat-001">
      <description> Test to hit EvaluateOptional on MapConcatSingle </description>
      <created by="Oliver Hallam" on="2008-07-23"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <dependency type="spec" value="XQ10+"/>      
      <test>declare function local:f($x) { if ($x) then true() else () }; declare function local:g($x) { if ($x) then "true" else "false" }; let $x := local:g(true()) for $y in local:f($x) return ($y, $x)</test>
      <result>
         <assert-string-value>true true</assert-string-value>
      </result>
   </test-case>
   

   <test-case name="cbcl-while-map-concat-002">
      <description> Test to hit Evaluate on MapConcatOptional </description>
      <created by="Oliver Hallam" on="2008-07-23"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <dependency type="spec" value="XQ10+"/>      
      <test>declare function local:f($x) { if ($x) then true() else () }; empty(for $x in local:f(false()), $y in 1 to 10 return ($x, $y))</test>
      <result>
         <assert-true/>
      </result>
   </test-case>
   

   <test-case name="cbcl-while-map-concat-003">
      <description> Test product with optional input </description>
      <created by="Oliver Hallam" on="2008-07-23"/>
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <dependency type="spec" value="XQ10+"/>      
      <test>declare function local:f($x) { if ($x) then true() else () }; for $x in local:f(true()), $y in 1 to 10 return ($x, $y)</test>
      <result>
         <assert-string-value>true 1 true 2 true 3 true 4 true 5 true 6 true 7 true 8 true 9 true 10</assert-string-value>
      </result>
   </test-case>
   

   <test-case name="cbcl-while-left-outer-join-002">
      <description> A left outer join that requires tricky predicate hoisting to spot. </description>
      <created by="Oliver Hallam" on="2008-07-23"/>      
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <modified by="Gunther Rademacher" on="2025-03-04" change="Make test independent of boundary space in result"/>
      <test><![CDATA[
         <e> { for $x in 1 to 10 return <a>{
                  for $y in 1 to 10 while $x > 7 and $y = $x return $y
               }</a> } </e>]]></test>
      <result>
         <assert-xml><![CDATA[<e><a/><a/><a/><a/><a/><a/><a/><a/><a/><a/></e>]]></assert-xml>
      </result>
   </test-case>
   

   <test-case name="cbcl-while-left-outer-join-003">
      <description> A left outer join with multiple predicates </description>
      <created by="Oliver Hallam" on="2008-07-24"/>      
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test><![CDATA[
         <e> { for $x in 1 to 10 while $x > 7 return <a>{
                  for $y in 1 to 10 while $y = $x return $y}</a> 
              } </e>]]></test>
      <result>
         <assert-xml><![CDATA[<e/>]]></assert-xml>
      </result>
   </test-case>
   
   <test-case name="cbcl-while-left-outer-join-004">
      <description/>
      <created by="Nick Jones" on="2010-03-24"/>      
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <modified by="Gunther Rademacher" on="2025-03-04" change="Make test independent of boundary space in result"/>
      <test><![CDATA[<tbody> { 
         let $rows := <tables> <table> <row> <entry>Acetazolamide</entry> <entry>Acetazolamide</entry> </row> <row> <entry>Acetazolamide sodium</entry> <entry>Acetazolamide sodium</entry> </row> </table> <table> <row> <entry>Acetylcholine chloride</entry> <entry>Acetylcholine chloride</entry> </row> </table> <table> <row> <entry>Acetylcysteine</entry> <entry>Acetylcysteine</entry> </row> <row> <entry>Acetylcysteine sodium</entry> <entry>Acetylcysteine sodium</entry> </row> </table> </tables>/table/row 
         return for $g in distinct-values($rows/entry[2][string(.)])  
                order by $g 
                return let $matches := for $row in $rows 
                                       while $g = string($row/entry[2][string(.)]) 
                                       return $row/entry[1] 
                       return <entry> { $matches/( <link> { node() } </link>, text { if (position() lt last()) then '; ' else () } ) } </entry> 
         } </tbody>]]></test>
      <result>
         <assert-xml><![CDATA[<tbody><entry><link>Acetazolamide</link></entry><entry/><entry/><entry/><entry/></tbody>]]></assert-xml>
      </result>
   </test-case>
   
   <test-case name="cbcl-while-hash-join-012">
      <description> Tests hash join between anyAtomicType containing only untypedAtomic and string </description>
      <created by="Nick Jones" on="2009-04-02"/>      
      <modified by="Michael Kay" on="2024-01-11" change="adapted 'where' test to create 'while' test"/>
      <test><![CDATA[
         declare variable $strings := ('1','2'); 
         declare variable $untypeds := (<untyped>1</untyped>,<untyped>2</untyped>); 
         for $string in $strings 
         for $untyped in $untypeds 
         while $untyped = $string 
         return $string]]></test>
      <result>
         <assert-string-value>1</assert-string-value>
      </result>
   </test-case>
</test-set>
